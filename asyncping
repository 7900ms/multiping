#!/usr/bin/env python3

import argparse
import asyncio
import curses
import re


class Task(object):
    def __init__(self, window, hosts, *args):
        self.window = window
        self.args = args
        max_host_length = max(len(host) for host in hosts)
        max_host_length = min(max_host_length, 28)
        self.host_col_length = max_host_length

        _, width = window.getmaxyx()
        self.avg_col_pos = width - 7
        self.loss_col_pos = self.avg_col_pos - 7
        self.output_col_length = self.loss_col_pos - self.host_col_length - 4

        window.addstr('HOST'.ljust(max_host_length) + '  ' + 'PING OUTPUT', curses.A_BOLD)
        window.addstr(0, self.avg_col_pos, 'AVG(ms)', curses.A_BOLD)
        window.addstr(0, self.loss_col_pos, 'LOSS'.rjust(5), curses.A_BOLD)
        for i, host in enumerate(hosts):
            if len(host) <= max_host_length:
                window.addstr(i + 1, 0, host.ljust(max_host_length))
            else:
                window.addstr(i + 1, 0, host[:max_host_length - 4] + '... ')
        window.refresh()

        loop = asyncio.get_event_loop()
        coros = [self.ping(host, i) for i, host in enumerate(hosts)]
        commands = asyncio.gather(*coros)
        loop.run_until_complete(commands)
        loop.close()

    def add_output(self, y, output, *args):
        if len(output) > self.output_col_length:
            pos = (self.output_col_length - 3) // 2
            output = '{}...{}'.format(output[:pos], output[-pos:])
        self.window.addstr(y, self.host_col_length + 2, output.ljust(self.output_col_length), *args)

    async def ping(self, host, cid):
        process = await asyncio.create_subprocess_exec(
            'ping',
            host,
            *self.args,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        while True:
            stdout = await process.stdout.readline()
            if not stdout:
                _, stderr = await process.communicate()
                if stderr:
                    self.add_output(cid + 1, stderr.decode(), curses.color_pair(1))
                    self.window.refresh()
                break

            line = stdout.decode().strip()
            self.add_output(cid + 1, line)

            res = parse_rtt(line)
            if res:
                avg_col = res.groupdict()['avg'].rjust(7)
                self.window.addstr(cid + 1, self.avg_col_pos, avg_col)

            res = parse_loss(line)
            if res:
                loss_col = res.groupdict()['loss'].rjust(5)
                self.window.addstr(cid + 1, self.loss_col_pos, loss_col)

            self.window.refresh()


def parse_rtt(line):
    pattern = r'^(round-trip|rtt) min/avg/max/(std|m)dev = (?P<min>.+)/(?P<avg>.+)/(?P<max>.+)/(?P<dev>.+) ms$'
    return re.match(pattern, line)


def parse_loss(line):
    pattern = r'^(?P<trans>\d+) packets transmitted, (?P<recv>\d+) (packets )?received, (?P<loss>.+) packet loss(, time (?P<time>.+))?$'
    return re.match(pattern, line)


def get_arguments():
    """get arguments from user input
    :return:Namespace object
    """
    parser = argparse.ArgumentParser()

    parser.add_argument('host', nargs='*', help='host to ping')
    parser.add_argument('--input', metavar='input_file', help='file contains hosts, one host per line',
                        type=argparse.FileType('r'))

    arguments = parser.parse_args()

    if arguments.host and arguments.input:
        parser.error('too many arguments, you can NOT specify both host(s) and input file')

    if not arguments.host and not arguments.input:
        parser.error('too few arguments, you must specify input file or at least one host')

    arguments.host_list = arguments.host or arguments.input.read().split()

    return arguments


def main(window, arguments):
    curses.use_default_colors()
    curses.init_pair(1, curses.COLOR_RED, -1)
    curses.curs_set(0)

    y, x = window.getmaxyx()
    errors = []
    if y < len(arguments.host_list) + 2:
        errors.append('not enough lines')
    if x < 80:
        errors.append('not enough columns')

    if errors:
        [window.addstr('ERROR: {}\n'.format(error), curses.color_pair(1)) for error in errors]
        window.addstr('Your window is too small to properly display results, resize it and try again.\n', curses.color_pair(1))
        window.addstr('Press any key to exit...')

    else:
        Task(window, arguments.host_list, '-c', '30', '-i', '0.1')
        window.addstr(len(arguments.host_list) + 1, 0, 'Press any key to exit...')

    window.refresh()
    window.getch()
    curses.endwin()


if __name__ == '__main__':
    args = get_arguments()
    curses.wrapper(main, args)

